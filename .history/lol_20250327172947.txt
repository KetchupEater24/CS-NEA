CREATE TABLE IF NOT EXISTS USERS (
    USER_ID INTEGER PRIMARY KEY AUTOINCREMENT,
    USERNAME TEXT UNIQUE NOT NULL,
    EMAIL TEXT UNIQUE NOT NULL,
    PASSWORD_HASH TEXT NOT NULL
);

CREATE TABLE IF NOT EXISTS DECKS (
    DECK_ID INTEGER PRIMARY KEY AUTOINCREMENT,
    USER_ID INTEGER NOT NULL,
    DECK_NAME TEXT NOT NULL,
    FOREIGN KEY (USER_ID) REFERENCES USERS(USER_ID) ON DELETE CASCADE
);

CREATE TABLE IF NOT EXISTS CARDS (
    CARD_ID INTEGER PRIMARY KEY AUTOINCREMENT,
    DECK_ID INTEGER NOT NULL,
    QUESTION TEXT NOT NULL,
    ANSWER TEXT NOT NULL,
    DIFFICULTY INTEGER NOT NULL,
    FOREIGN KEY (DECK_ID) REFERENCES DECKS(DECK_ID)
);

CREATE TABLE IF NOT EXISTS QUIZ_RESULTS (
    RESULT_ID INTEGER PRIMARY KEY AUTOINCREMENT,
    USER_ID INTEGER NOT NULL,
    DECK_ID INTEGER NOT NULL,
    CARD_ID INTEGER NOT NULL,
    IS_CORRECT BOOLEAN,
    TOTAL_CARDS INTEGER,
    TOTAL_TIME FLOAT,
    AVG_TIME FLOAT,
    TIMESTAMP DATETIME DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (USER_ID) REFERENCES USERS(USER_ID),
    FOREIGN KEY (DECK_ID) REFERENCES DECKS(DECK_ID),
    FOREIGN KEY (CARD_ID) REFERENCES CARDS(CARD_ID)
);

CREATE TABLE IF NOT EXISTS CARD_ATTEMPTS (
    ATTEMPT_ID INTEGER PRIMARY KEY AUTOINCREMENT,
    USER_ID INTEGER NOT NULL,
    DECK_ID INTEGER NOT NULL,
    CARD_ID INTEGER NOT NULL,
    TIME_TAKEN FLOAT,
    IS_CORRECT BOOLEAN,
    TIMESTAMP DATETIME DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (USER_ID) REFERENCES USERS(USER_ID),
    FOREIGN KEY (DECK_ID) REFERENCES DECKS(DECK_ID),
    FOREIGN KEY (CARD_ID) REFERENCES CARDS(CARD_ID)
);



FUNCTION GET_DECK_INFO(DECK_ID)
    EXECUTE SQL "SELECT d.DECK_NAME, COUNT(c.CARD_ID) AS CARD_COUNT FROM DECKS d LEFT JOIN CARDS c ON d.DECK_ID = c.DECK_ID WHERE d.DECK_ID = ? GROUP BY d.DECK_ID, d.DECK_NAME" WITH PARAMETER DECK_ID
    IF RESULT EXISTS THEN
        RETURN DICTIONARY { "name": RESULT.DECK_NAME, "card_count": RESULT.CARD_COUNT }
    ELSE
        RETURN DICTIONARY { "name": "", "card_count": 0 }
    END IF
END FUNCTION

FUNCTION GET_CARD_COUNT(DECK_ID)
    EXECUTE SQL "SELECT COUNT(*) FROM CARDS WHERE DECK_ID = ?" WITH PARAMETER DECK_ID
    IF RESULT EXISTS THEN
        RETURN RESULT.COUNT
    ELSE
        RETURN 0
    END IF
END FUNCTION

CLASS DECK_NODE
    MEMBER DECK_ID, DECK_NAME, AVG_EF, CARD_COUNT, LEFT, RIGHT
    CONSTRUCTOR(DECK_ID, DECK_NAME, AVG_EF, CARD_COUNT)
        SET SELF.DECK_ID TO DECK_ID
        SET SELF.DECK_NAME TO DECK_NAME
        SET SELF.AVG_EF TO AVG_EF
        SET SELF.CARD_COUNT TO CARD_COUNT
        SET SELF.LEFT TO NULL
        SET SELF.RIGHT TO NULL
    END CONSTRUCTOR
END CLASS

FUNCTION INSERT_NODE(ROOT, NODE)
    IF ROOT IS NULL THEN
        RETURN NODE
    END IF
    IF NODE.AVG_EF < ROOT.AVG_EF THEN
        SET ROOT.LEFT TO INSERT_NODE(ROOT.LEFT, NODE)
    ELSE
        SET ROOT.RIGHT TO INSERT_NODE(ROOT.RIGHT, NODE)
    END IF
    RETURN ROOT
END FUNCTION

FUNCTION IN_ORDER(TRAVERSE_ROOT)
    DECLARE NODES AS EMPTY LIST
    IF TRAVERSE_ROOT IS NOT NULL THEN
        SET NODES TO IN_ORDER(TRAVERSE_ROOT.LEFT)
        APPEND TRAVERSE_ROOT TO NODES
        APPEND IN_ORDER(TRAVERSE_ROOT.RIGHT) TO NODES
    END IF
    RETURN NODES
END FUNCTION

FUNCTION MERGE_SORT(LEFT_LIST, RIGHT_LIST)
    DECLARE RESULT AS EMPTY LIST
    WHILE LEFT_LIST IS NOT EMPTY AND RIGHT_LIST IS NOT EMPTY DO
        IF FIRST ELEMENT OF LEFT_LIST < FIRST ELEMENT OF RIGHT_LIST THEN
            REMOVE FIRST ELEMENT FROM LEFT_LIST AND APPEND IT TO RESULT
        ELSE
            REMOVE FIRST ELEMENT FROM RIGHT_LIST AND APPEND IT TO RESULT
        END IF
    END WHILE
    IF LEFT_LIST IS NOT EMPTY THEN
        APPEND REMAINING ELEMENTS OF LEFT_LIST TO RESULT
    ELSE
        APPEND REMAINING ELEMENTS OF RIGHT_LIST TO RESULT
    END IF
    RETURN RESULT
END FUNCTION

FUNCTION HASH_PASSWORD(PASSWORD)
    DECLARE CHARS AS "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789"
    DECLARE SALT AS EMPTY STRING
    FOR I FROM 1 TO 8 DO
        SET SALT TO SALT + RANDOM_CHOICE_FROM(CHARS)
    END FOR
    DECLARE NUM AS 0
    FOR EACH CHARACTER IN (PASSWORD + SALT) DO
        SET NUM TO NUM + ASCII_VALUE(CHARACTER)
    END FOR
    SET NUM TO NUM MOD 1000
    RETURN SALT + "$" + FORMAT(NUM, "04x")
END FUNCTION

FUNCTION SPLIT_AND_SORT(CARDS_LIST)
    IF LENGTH OF CARDS_LIST <= 1 THEN
        RETURN CARDS_LIST
    END IF
    DECLARE MID AS INTEGER = LENGTH OF CARDS_LIST DIVIDED BY 2
    DECLARE LEFT_LIST AS SPLIT_AND_SORT(SUBLIST OF CARDS_LIST FROM START TO MID)
    DECLARE RIGHT_LIST AS SPLIT_AND_SORT(SUBLIST OF CARDS_LIST FROM MID TO END)
    RETURN MERGE_SORT(LEFT_LIST, RIGHT_LIST)
END FUNCTION

FUNCTION SCHEDULE_NEXT_REVIEW(USER_ID, CARD_ID, IS_CORRECT, CURRENT_INTERVAL, CURRENT_EF)
    IF IS_CORRECT THEN
        SET REPETITION TO REPETITION + 1
        SET NEW_INTERVAL TO CURRENT_INTERVAL * CURRENT_EF
        SET NEW_EF TO CURRENT_EF + ADJUSTMENT_FACTOR
    ELSE
        SET REPETITION TO 0
        SET NEW_INTERVAL TO 1
        SET NEW_EF TO MAX(1.3, CURRENT_EF - PENALTY)
    END IF
    SET NEXT_REVIEW_DATE TO CURRENT_DATE + NEW_INTERVAL
    EXECUTE SQL "UPDATE SPACED_REP SET REPETITION = ?, INTERVAL = ?, EF = ?, NEXT_REVIEW_DATE = ? WHERE USER_ID = ? AND CARD_ID = ?" WITH PARAMETERS (REPETITION, NEW_INTERVAL, NEW_EF, NEXT_REVIEW_DATE, USER_ID, CARD_ID)
END FUNCTION

FUNCTION UPDATE_DECK_LIST()
    CLEAR DECK_DISPLAY_CONTAINER
    DECLARE DECK_LIST AS EMPTY LIST
    FOR EACH DECK IN DATABASE_GET_DECKS(USER_ID) DO
        DECLARE CARDS = DATABASE_GET_CARDS(DECK.ID)
        IF CARDS IS NOT EMPTY THEN
            DECLARE TOTAL_EF = 0
            FOR EACH CARD IN CARDS DO
                SET TOTAL_EF TO TOTAL_EF + DATABASE_GET_CARD_EASINESS(USER_ID, CARD.ID)
            END FOR
            SET AVG_EF TO TOTAL_EF / LENGTH OF CARDS
        ELSE
            SET AVG_EF TO 2.5
        END IF
        DECLARE CARD_COUNT = DATABASE_GET_CARD_COUNT(DECK.ID)
        ADD TUPLE (DECK.ID, DECK.NAME, AVG_EF, CARD_COUNT) TO DECK_LIST
    END FOR
    DECLARE ROOT AS NULL
    FOR EACH ITEM IN DECK_LIST DO
        CREATE NODE WITH (ITEM.ID, ITEM.NAME, ITEM.AVG_EF, ITEM.CARD_COUNT)
        SET ROOT TO INSERT_NODE(ROOT, NODE)
    END FOR
    DECLARE SORTED_DECKS = IN_ORDER(ROOT)
    DECLARE ROW = 0, COL = 0
    FOR EACH NODE IN SORTED_DECKS DO
        CREATE DECK_CONTAINER OBJECT WITH NODE'S DATA
        PLACE DECK_CONTAINER AT GRID POSITION (ROW, COL)
        SET COL TO COL + 1
        IF COL EQUALS MAX_COLUMNS THEN
            SET COL TO 0
            SET ROW TO ROW + 1
        END IF
    END FOR
END FUNCTION

FUNCTION PLACE_OBJECTS_IN_GRID(OBJECT_LIST, MAX_COLUMNS)
    DECLARE ROW = 0, COL = 0
    FOR EACH OBJECT IN OBJECT_LIST DO
        PLACE OBJECT AT GRID[ROW][COL]
        SET COL TO COL + 1
        IF COL EQUALS MAX_COLUMNS THEN
            SET COL TO 0
            SET ROW TO ROW + 1
        END IF
    END FOR
END FUNCTION

FUNCTION GET_USER(USER_ID)
    EXECUTE SQL "SELECT USERNAME, EMAIL, PASSWORD_HASH FROM USERS WHERE USER_ID = ?" WITH PARAMETER USER_ID
    IF RESULT EXISTS THEN
        RETURN DICTIONARY { "username": RESULT.USERNAME, "email": RESULT.EMAIL, "password": RESULT.PASSWORD_HASH }
    ELSE
        RETURN NULL
    END IF
END FUNCTION
